import 'package:equatable/equatable.dart';

class Point extends Equatable{
  const Point(this.x, this.y);
  final int x;
  final int y;

  @override
  List<Object?> get props => [x, y];

  @override
  bool get stringify => true;

  Point operator +(Point other) {
    return Point(x + other.x, y + other.y);
  }

  Point operator *(int other) {
    return Point(x * other, y * other);
  }
}

void main() {
  print(Point(0, 0) == Point(0, 0));
  print(Point(1, 1));
}

// In summart, we have seen that it's good practice to override the equality 'hashCode' and 'toString()' methods when we create our own classes
// if we have a lot of classes, it can become tedious to ocerride all these things
// Equatable package solves this problem for us






// é€™ä»½ `Object` é¡åˆ¥çš„åŸå§‹ç¢¼æ˜¯ Dart èªè¨€çš„éˆé­‚ï¼Œå®ƒå®šç¾©äº†æ‰€æœ‰ç‰©ä»¶æœ€åº•å±¤çš„è¡Œç‚ºã€‚å…¶ä¸­ `hashCode` æ˜¯ä¸€å€‹éå¸¸æ·±å¥§ä¸”é‡è¦çš„æ¦‚å¿µã€‚

// ä»¥ä¸‹ç‚ºä½ æ•´ç†å‡ºé—œæ–¼ `hashCode` æœ€å®Œæ•´çš„ä»‹ç´¹ï¼Œåˆ†ç‚º**æ¦‚å¿µã€é‹ç®—åŸç†ã€è¦å‰‡ã€ä»¥åŠå¯¦ä½œæŠ€å·§**å››å€‹ç¶­åº¦ã€‚

// ---

// ### ä¸€ã€ ä»€éº¼æ˜¯ `hashCode`ï¼Ÿ (åŸºæœ¬æ¦‚å¿µ)

// `hashCode`ï¼ˆé›œæ¹Šç¢¼ï¼‰æ˜¯ä¸€å€‹ **æ•´æ•¸ (int)**ï¼Œå®ƒä»£è¡¨äº†ä¸€å€‹ç‰©ä»¶åœ¨æŸä¸€æ™‚åˆ»çš„ã€Œæ•¸ä½æŒ‡ç´‹ã€ã€‚

// * **å®ƒçš„ç”¨é€”**ï¼šä¸»è¦ç”¨æ–¼**å¿«é€Ÿå°‹æ‰¾**ã€‚åœ¨ `HashMap`ï¼ˆéµå€¼å°ï¼‰æˆ– `HashSet`ï¼ˆé›†åˆï¼‰ä¸­ï¼Œé›»è…¦ä¸æœƒä¸€å€‹ä¸€å€‹æ¯”å°ç‰©ä»¶æ˜¯å¦ç›¸ç­‰ï¼Œè€Œæ˜¯å…ˆçœ‹ `hashCode` æŠŠç‰©ä»¶ä¸Ÿé€²ä¸åŒçš„ã€Œæ¡¶å­ (Buckets)ã€è£¡ï¼Œè—‰æ­¤å¤§å¹…æå‡æœå°‹é€Ÿåº¦ã€‚
// * **æœå°‹æ•ˆç‡æ¯”è¼ƒ**ï¼š
// * **ä¸€èˆ¬ List**ï¼šæœå°‹ä¸€å€‹æ±è¥¿è¦å¾é ­çœ‹åˆ°å°¾ï¼ˆæ™‚é–“è¤‡é›œåº¦ ï¼‰ã€‚
// * **Hash é›†åˆ**ï¼šå…ˆç®— `hashCode` ç›´æ¥è·³åˆ°ç›®æ¨™ä½ç½®ï¼ˆå¹³å‡æ™‚é–“è¤‡é›œåº¦ ï¼‰ã€‚



// ---

// ### äºŒã€ `hashCode` èˆ‡ `==` çš„ç¥è–å¥‘ç´„ (The Contract)

// åœ¨åŸå§‹ç¢¼ä¸­ï¼Œ`Object` é¡åˆ¥å¼·èª¿äº†ä¸€æ¢éµå¾‹ï¼š**å¦‚æœä½ è¦†å¯«äº† `==` é‹ç®—å­ï¼Œä½ å°±ã€Œå¿…é ˆã€åŒæ™‚è¦†å¯« `hashCode`ã€‚**

// é€™å…©è€…ä¹‹é–“æœ‰ä¸€å¥—ä¸å¯é•èƒŒçš„é‚è¼¯ï¼š

// 1. **è‹¥ A == B ç‚ºçœŸ**ï¼šé‚£éº¼ `A.hashCode` **å¿…é ˆç­‰æ–¼** `B.hashCode`ã€‚
// * *åŸå› *ï¼šå¦‚æœå…©å€‹äººè¢«åˆ¤å®šæ˜¯åŒä¸€å€‹äººï¼ˆç›¸ç­‰ï¼‰ï¼Œä½†ä»–å€‘è¢«ä¸Ÿé€²ä¸åŒçš„æ¡¶å­ï¼ˆhashCode ä¸åŒï¼‰ï¼Œé‚£ `Map` å°±æœƒæ‰¾ä¸åˆ°ä»–å€‘ã€‚


// 2. **è‹¥ A.hashCode == B.hashCode**ï¼šå…©è€…**ä¸ä¸€å®š**ç›¸ç­‰ï¼ˆé€™ç¨±ç‚ºã€Œé›œæ¹Šç¢°æ’ Collisionã€ï¼‰ã€‚
// * *åŸå› *ï¼šå°±åƒå…©å€‹äººå‰›å¥½åŒå§“ï¼ˆåŒä¸€æ¡¶å­ï¼‰ï¼Œä½†ä»–å€‘ä¸ä¸€å®šæ˜¯åŒä¸€å€‹äººã€‚é€™æ™‚ `Map` æœƒåœ¨åŒä¸€å€‹æ¡¶å­å…§é€²ä¸€æ­¥ç”¨ `==` ä¾†ç¢ºèªã€‚


// 3. **è‹¥ A != B**ï¼š`hashCode` æœ€å¥½ä¸åŒï¼Œä½†ç›¸åŒä¹Ÿåˆæ³•ã€‚
// * *æç¤º*ï¼šé›œæ¹Šç¢°æ’è¶Šå°‘ï¼Œæ•ˆèƒ½å°±è¶Šå¥½ã€‚



// ---

// ### ä¸‰ã€ åŸå§‹ç¢¼ä¸­çš„ `hashCode` å¯¦ä½œæ–¹å¼

// å¾ä½ æä¾›çš„åŸå§‹ç¢¼ä¸­ï¼Œæˆ‘å€‘å¯ä»¥çœ‹åˆ°ä¸‰ç¨®è™•ç† `hashCode` çš„æ–¹å¼ï¼š

// #### 1. é è¨­è¡Œç‚º (Identity)

// ```dart
// external int get hashCode;

// ```

// * `external` ä»£è¡¨é€™æ˜¯åœ¨ Dart è™›æ“¬æ©Ÿ (VM) åº•å±¤å¯¦ä½œçš„ã€‚
// * **é è¨­è¦å‰‡**ï¼šæ¯å€‹ç‰©ä»¶çš„ `hashCode` æ˜¯æ ¹æ“šå®ƒåœ¨è¨˜æ†¶é«”ä¸­çš„å”¯ä¸€èº«åˆ†ç”¢ç”Ÿçš„ã€‚é™¤éæ˜¯åŒä¸€å€‹å¯¦é«”ï¼Œå¦å‰‡ `hashCode` å¹¾ä¹ä¸æœƒé‡è¤‡ã€‚

// #### 2. å¤šæ¬„ä½çµ„åˆï¼š`Object.hash` (æ–°ç‰ˆ Dart 2.14+)

// ç•¶ä½ çš„é¡åˆ¥æœ‰å¾ˆå¤šå€‹æ¬„ä½éœ€è¦åƒèˆ‡æ¯”è¼ƒæ™‚ï¼ŒåŸå§‹ç¢¼æä¾›äº† `static int hash(...)` æ–¹æ³•ï¼š

// ```dart
// static int hash(Object? object1, Object? object2, ...) { ... }

// ```

// å®ƒæœƒæŠŠå‚³é€²å»çš„åƒæ•¸ï¼ˆæœ€å¤š 20 å€‹ï¼‰ä¾ç…§é †åºé€²è¡Œè¤‡é›œçš„ä½å…ƒé‹ç®—ï¼Œå›å‚³ä¸€å€‹åˆä½µå¾Œçš„é›œæ¹Šå€¼ã€‚

// #### 3. é›†åˆè™•ç†ï¼š`Object.hashAll` èˆ‡ `hashAllUnordered`

// * **`hashAll`**ï¼šé©åˆ `List`ã€‚é †åºä¸åŒï¼Œçµæœå°±ä¸åŒã€‚
// * **`hashAllUnordered`**ï¼šé©åˆ `Set`ã€‚åªè¦å…§å®¹ç‰©ä¸€æ¨£ï¼Œé †åºä¸åŒä¹Ÿæœƒå›å‚³ç›¸åŒçš„ `hashCode`ã€‚

// ---

// ### å››ã€ å¸¸è¦‹çš„é™·é˜± (Pitfalls)

// 1. **ä½¿ç”¨é final æ¬„ä½è¨ˆç®— hashCode**ï¼š
// å¦‚æœä½ åœ¨ç‰©ä»¶å»ºç«‹å¾Œä¿®æ”¹äº†å½±éŸ¿ `hashCode` çš„è®Šæ•¸ï¼Œé‚£éº¼é€™å€‹ç‰©ä»¶åœ¨ `Set` æˆ– `Map` ä¸­å°±æœƒè®Šæˆã€Œå¤±è¹¤äººå£ã€ï¼Œå› ç‚ºå®ƒç®—å‡ºä¾†çš„æ¡¶å­ä½ç½®è®Šäº†ï¼Œä½†å®ƒäººé‚„åœ¨èˆŠçš„æ¡¶å­è£¡ã€‚
// 2. **æ•ˆèƒ½ä½è½çš„å¯¦ä½œ**ï¼š
// å¦‚æœä½ å¯« `int get hashCode => 1;`ï¼ˆæ‰€æœ‰ç‰©ä»¶éƒ½å›å‚³ 1ï¼‰ï¼Œé€™æ˜¯åˆæ³•çš„ï¼Œä½†é€™æœƒè®“ä½ çš„ `Map` è®Šæˆä¸€å€‹æ™®é€šçš„ `List`ï¼Œæœå°‹æ•ˆèƒ½å¾  æ…˜è·Œåˆ° ã€‚
// 3. **å¿˜è¨˜åŒæ­¥**ï¼š
// è¦†å¯«äº† `==` å»æ²’è¦†å¯« `hashCode`ã€‚é€™æœƒå°è‡´å…©å€‹å…§å®¹å®Œå…¨ä¸€æ¨£çš„ç‰©ä»¶ï¼Œç„¡æ³•åœ¨ `Set` ä¸­è¢«å»é‡ã€‚

// ### ğŸš€ ç¸½çµ

// `hashCode` æ˜¯ç‚ºäº†è®“ç‰©ä»¶èƒ½è¢«**é«˜æ•ˆåœ°åˆ†é¡èˆ‡æª¢ç´¢**ã€‚åœ¨ Dart ä¸­ï¼Œè«‹è¨˜ä½é€™å€‹å£è¨£ï¼š**ã€Œè¦å¹³ç­‰ (`==`)ï¼Œå°±è¦åŒç¢¼ (`hashCode`)ï¼›è¦é˜²å‘†ï¼Œå°±ç”¨ `Object.hash`ã€‚ã€**








// Dart Object é¡åˆ¥ï¼šåŸå§‹ç¢¼è¨»é‡‹ç¿»è­¯èˆ‡æ ¸å¿ƒç­†è¨˜

// Object æ˜¯ Dart ä¸­é™¤äº† null ä»¥å¤–æ‰€æœ‰é¡åˆ¥çš„åŸºçŸ³ã€‚ä»¥ä¸‹å°‡åŸå§‹ç¢¼ä¸­çš„é‡è¦è¨»é‡‹ç¿»è­¯ç‚ºä¸­æ–‡ï¼Œä¸¦æ•´ç†å‡ºé–‹ç™¼è€…å¿…é ˆæŒæ¡çš„ã€Œç¡¬æ ¸ã€ç­†è¨˜ã€‚

// 1. é¡åˆ¥ç¸½é«”å®šç¾© (Class Definition)

// åŸå§‹è¨»é‡‹ç¿»è­¯ï¼š
// ã€Œé™¤äº† null ä¹‹å¤–ï¼Œæ‰€æœ‰ Dart ç‰©ä»¶çš„åŸºé¡ã€‚å› ç‚º Object æ˜¯éç©ºé¡åˆ¥å±¤ç´šçµæ§‹çš„æ ¹ï¼Œæ‰€ä»¥æ¯å€‹é Null çš„ Dart é¡åˆ¥éƒ½æ˜¯ Object çš„å­é¡ã€‚ç•¶ä½ å®šç¾©ä¸€å€‹é¡åˆ¥æ™‚ï¼Œä½ æ‡‰è©²è€ƒæ…®è¦†å¯« toString ä»¥è¿”å›æè¿°è©²é¡åˆ¥å¯¦ä¾‹çš„å­—ä¸²ã€‚ã€

// ğŸ’¡ æ ¸å¿ƒç­†è¨˜ï¼š

// çµ•å°ç¹¼æ‰¿ï¼šåœ¨ Dart ä¸­ï¼Œä½ ä¸éœ€è¦å¯« extends Objectï¼Œç³»çµ±æœƒè‡ªå‹•å¹«ä½ åŠ ä¸Šã€‚

// Null çš„ä¾‹å¤–ï¼šåœ¨ Null Safety ä¹‹å¾Œï¼ŒObject ä»£è¡¨ã€Œä¸ç‚ºç©ºçš„è¬ç‰©ã€ã€‚

// 2. ç›¸ç­‰é‹ç®—å­ (operator ==) çš„å››æ¢æˆ’å¾‹

// åŸå§‹è¨»é‡‹ç¿»è­¯ï¼š
// ã€Œé è¨­è¡Œç‚ºæ˜¯åªæœ‰ç•¶å…©å€‹ç‰©ä»¶æ˜¯ã€åŒä¸€å€‹ç‰©ä»¶ã€æ™‚æ‰è¿”å› trueã€‚è¦†å¯«æ­¤æ–¹æ³•æ™‚ï¼Œå¿…é ˆéµå¾ªã€ç­‰åƒ¹é—œä¿‚ã€ï¼ŒåŒ…å«ï¼šã€

// å…¨é«”æ€§ (Total)ï¼šå¿…é ˆå°æ‰€æœ‰å¼•æ•¸è¿”å›å¸ƒæ—å€¼ï¼Œçµ•ä¸èƒ½æ‹‹å‡ºéŒ¯èª¤ã€‚

// è‡ªåæ€§ (Reflexive)ï¼šå°æ–¼ä»»ä½•ç‰©ä»¶ oï¼Œo == o å¿…é ˆç‚ºçœŸã€‚

// å°ç¨±æ€§ (Symmetric)ï¼šè‹¥ o1 == o2 ç‚ºçœŸï¼Œå‰‡ o2 == o1 ä¹Ÿå¿…é ˆç‚ºçœŸã€‚

// å‚³éæ€§ (Transitive)ï¼šè‹¥ o1 == o2 ä¸” o2 == o3 ç‚ºçœŸï¼Œå‰‡ o1 == o3 å¿…é ˆç‚ºçœŸã€‚

// ğŸ’¡ æ ¸å¿ƒç­†è¨˜ï¼š

// ä¸€è‡´æ€§ï¼šé™¤éç‰©ä»¶è¢«ä¿®æ”¹ï¼Œå¦å‰‡æ¯”è¼ƒçš„çµæœåœ¨ä¸€æ®µæ™‚é–“å…§æ‡‰è©²ä¿æŒä¸è®Šã€‚

// é€£å‹•ç¾©å‹™ï¼šåŸå§‹ç¢¼æ˜ç¢ºè¦æ±‚ï¼šã€Œè‹¥è¦†å¯«äº† ==ï¼Œå°±å¿…é ˆè¦†å¯« hashCodeã€ã€‚

// 3. é›œæ¹Šç¢¼ (hashCode) çš„é‹ä½œé‚è¼¯

// åŸå§‹è¨»é‡‹ç¿»è­¯ï¼š
// ã€Œé›œæ¹Šç¢¼æ˜¯ä¸€å€‹ä»£è¡¨ç‰©ä»¶ç‹€æ…‹çš„æ•´æ•¸ï¼Œæœƒå½±éŸ¿ == çš„æ¯”è¼ƒã€‚é è¨­çš„é›œæ¹Šç¢¼åƒ…ä»£è¡¨ç‰©ä»¶çš„ã€èº«åˆ† (Identity)ã€ã€‚å¦‚æœè¦†å¯«äº† == ä»¥ä½¿ç”¨ç‰©ä»¶ç‹€æ…‹ï¼Œå‰‡é›œæ¹Šç¢¼ä¹Ÿå¿…é ˆæ›´æ”¹ä»¥ä»£è¡¨è©²ç‹€æ…‹ï¼Œå¦å‰‡è©²ç‰©ä»¶å°‡ç„¡æ³•ç”¨æ–¼ Set å’Œ Map ç­‰åŸºæ–¼é›œæ¹Šçš„è³‡æ–™çµæ§‹ã€‚ã€

// ğŸ’¡ æ ¸å¿ƒç­†è¨˜ï¼š

// ç¢°æ’ (Collision)ï¼šä¸ç›¸ç­‰çš„ç‰©ä»¶å…è¨±æ“æœ‰ç›¸åŒçš„ hashCodeï¼Œä½†å¦‚æœç¢°æ’å¤ªé »ç¹ï¼Œæœƒé™ä½ HashMap çš„æ•ˆç‡ï¼ˆå¾ $O(1)$ é€€åŒ–åˆ° $O(n)$ï¼‰ã€‚

// åŒæ­¥æ€§ï¼šç›¸ç­‰çš„ç‰©ä»¶ï¼ˆ== ç‚º trueï¼‰çµ•å°è¦æœ‰ç›¸åŒçš„ hashCodeã€‚

// 4. toString èˆ‡ noSuchMethod

// åŸå§‹è¨»é‡‹ç¿»è­¯ï¼š

// toStringï¼šã€Œæä¾›ç‰©ä»¶çš„æ–‡å­—è¡¨ç¤ºï¼Œä¸»è¦ç”¨æ–¼åµéŒ¯ (Debugging) æˆ–è¨˜éŒ„ (Logging)ã€‚ã€

// noSuchMethodï¼šã€Œç•¶å­˜å–ä¸å­˜åœ¨çš„æ–¹æ³•æˆ–å±¬æ€§æ™‚è§¸ç™¼ã€‚é¡åˆ¥å¯ä»¥è¦†å¯«æ­¤æ–¹æ³•ï¼Œä»¥ç‚ºç„¡æ•ˆçš„å‹•æ…‹èª¿ç”¨æä¾›è‡ªå®šç¾©è¡Œç‚ºï¼ˆä¾‹å¦‚ Mock ç‰©ä»¶ï¼‰ã€‚ã€

// ğŸ’¡ æ ¸å¿ƒç­†è¨˜ï¼š

// noSuchMethod åªæœ‰åœ¨è®Šæ•¸å‹åˆ¥ç‚º dynamic æ™‚æ‰æœƒè¢«è§¸ç™¼ã€‚

// 5. ç¾ä»£é›œæ¹Šå·¥å…· (Static Hash Methods)

// é€™æ˜¯ Dart 2.14 ä¹‹å¾Œæ–°å¢çš„å¼·å¤§å·¥å…·ï¼ŒåŸå§‹ç¢¼ä¸­å±•ç¤ºäº†ä¸‰ç¨®è¨ˆç®—æ–¹å¼ï¼š

// A. Object.hash (åˆä½µå›ºå®šæ•¸é‡çš„è®Šæ•¸)

// åŸå§‹è¨»é‡‹ï¼šã€Œé€šéæ•¸å€¼çµ„åˆæ¯å€‹å¼•æ•¸çš„ hashCodeã€‚é€™ä¿è­‰äº†åœ¨å–®æ¬¡ç¨‹å¼åŸ·è¡ŒæœŸé–“çš„ä¸€è‡´æ€§ã€‚ã€

// ç­†è¨˜ï¼šå®ƒèƒ½è™•ç†æœ€å¤š 20 å€‹åƒæ•¸ï¼Œç”šè‡³é€£ null ä¹Ÿèƒ½æ­£ç¢ºè™•ç†ã€‚

// B. Object.hashAll (é †åºç›¸é—œçš„é›†åˆ)

// åŸå§‹è¨»é‡‹ï¼šã€ŒæŒ‰ç–Šä»£é †åºåˆä½µå…ƒç´ çš„é›œæ¹Šç¢¼ã€‚hashAll([o]) çš„çµæœä¸ç­‰æ–¼ o.hashCodeã€‚ã€

// ç­†è¨˜ï¼šå¦‚æœä½ æœ‰ä¸€å€‹ List ä¸”é †åºå¾ˆé‡è¦ï¼Œè«‹ç”¨é€™å€‹ã€‚

// C. Object.hashAllUnordered (é †åºç„¡é—œçš„é›†åˆ)

// åŸå§‹è¨»é‡‹ï¼šã€Œä»¥ç¨ç«‹æ–¼é †åºçš„æ–¹å¼åˆä½µå…ƒç´ çš„é›œæ¹Šç¢¼ã€‚ã€

// ç­†è¨˜ï¼šå¦‚æœä½ åœ¨è™•ç† Setï¼ˆé›†åˆå…§å®¹ä¸€æ¨£ä½†é †åºå¯èƒ½ä¸åŒï¼‰ï¼Œé€™èƒ½ç¢ºä¿ç®—å‡ºç›¸åŒçš„é›œæ¹Šå€¼ã€‚

// ğŸ’ ç¸½çµï¼šåŸå§‹ç¢¼çµ¦é–‹ç™¼è€…çš„åº•å±¤æé†’

// èº«åˆ† vs ç‹€æ…‹ï¼šé è¨­çš„ Object åªèªã€Œèº«åˆ†ã€ï¼ˆä½ åœ¨è¨˜æ†¶é«”å“ªè£¡ï¼‰ï¼›è¦†å¯«å¾Œçš„é¡åˆ¥èªã€Œç‹€æ…‹ã€ï¼ˆä½ çš„è³‡æ–™å…§å®¹ï¼‰ã€‚

// å®‰å…¨ç¬¬ä¸€ï¼šoperator == çµ•ä¸èƒ½å™´éŒ¯ï¼ˆNever throwï¼‰ã€‚

// æ•ˆèƒ½é—œéµï¼šhashCode çš„å“è³ªæ±ºå®šäº† Map å’Œ Set çš„åŸ·è¡Œé€Ÿåº¦ã€‚

// ä¸å¯è®Šæ€§å»ºè­°ï¼šé›–ç„¶åŸå§‹ç¢¼æ²’æ˜èªªï¼Œä½† hashCode æœ€å¥½åªæ ¹æ“š final æ¬„ä½ä¾†è¨ˆç®—ï¼Œä»¥ç¶­æŒä¸€è‡´æ€§ã€‚



// åœ¨ä¹‹å‰çš„å­¸ç¿’ä¸­ï¼Œæˆ‘å€‘çŸ¥é“è¦è®“å…©å€‹ç‰©ä»¶ã€Œç›¸ç­‰ã€ï¼Œå¿…é ˆæ‰‹å‹•è¦†å¯« operator == å’Œ hashCodeï¼Œé€™éå¸¸éº»ç…©ä¸”å®¹æ˜“å‡ºéŒ¯ã€‚Equatable å¥—ä»¶å°±æ˜¯ç‚ºäº†è§£æ±ºé€™å€‹å•é¡Œè€Œç”Ÿçš„ã€Œæ•‘æ˜Ÿã€ã€‚
// åˆå­¸è€…å¿…è®€ç­†è¨˜
// 1. ç‚ºä»€éº¼è¦ç”¨ Equatableï¼Ÿ
// æ‰‹å¯«çš„ç—›è‹¦ï¼šè¦æ­£ç¢ºå¯¦ä½œ == å’Œ hashCode å¾ˆé›£ï¼Œä½ éœ€è¦è™•ç†å‹åˆ¥æª¢æŸ¥ã€null æª¢æŸ¥ã€é‚„è¦ç”¨è¤‡é›œçš„æ•¸å­¸ç®—é›œæ¹Šå€¼ã€‚åªè¦æ¼äº†ä¸€å€‹ï¼ŒSet å’Œ Map å°±æœƒå‡ºéŒ¯ã€‚

// Equatable çš„è§£æ³•ï¼šå®ƒæŠŠé€™äº›è¤‡é›œçš„é‚è¼¯å°è£åœ¨åº•å±¤ã€‚ä½ åªéœ€è¦å‘Šè¨´å®ƒï¼šã€Œæˆ‘çœ‹é‡çš„æ˜¯ x å’Œ y (get props => [x, y])ã€ï¼Œå‰©ä¸‹çš„å®ƒå…¨åŒ…äº†ã€‚

// 2. props æ˜¯ä»€éº¼ï¼Ÿ
// å®ƒæ˜¯ Properties (å±¬æ€§) çš„ç¸®å¯«ã€‚

// æŠŠå®ƒæƒ³åƒæˆä¸€å€‹ ã€Œç‰¹å¾µæ¸…å–®ã€ã€‚ä½ å‘Šè¨´é›»è…¦ï¼šã€Œåªè¦é€™å…©å€‹ç‰©ä»¶çš„ç‰¹å¾µæ¸…å–®ï¼ˆpropsï¼‰å…§å®¹ä¸€æ¨£ï¼Œå®ƒå€‘å°±æ˜¯é›™èƒèƒï¼ˆç›¸ç­‰ï¼‰ã€‚ã€

// 3. stringify æ˜¯ä»€éº¼ï¼Ÿ
// é€™æ˜¯ä¸€å€‹é–‹é—œã€‚

// æ‰“é–‹å¾Œ (true)ï¼ŒEquatable æœƒå¹«ä½ ç”¢ç”Ÿä¸€å€‹æ¼‚äº®çš„ toString() è¼¸å‡ºï¼Œè®“ä½ é™¤éŒ¯æ™‚ä¸ç”¨çœ‹åˆ° Instance of 'Point' é€™ç¨®æ²’ç”¨çš„è¨Šæ¯ã€‚



// /**
//  * ä¸»é¡Œï¼šEquatable å¥—ä»¶èˆ‡è‡ªå‹•åŒ–æ¯”è¼ƒ (Automated Equality)
//  * æ ¸å¿ƒç›®æ¨™ï¼šåˆ©ç”¨ Equatable è‡ªå‹•è™•ç† operator == å’Œ hashCode çš„è¦†å¯«å·¥ä½œï¼Œ
//  * è®“é–‹ç™¼è€…å°ˆæ³¨æ–¼å®šç¾©ã€Œå“ªäº›è³‡æ–™ä»£è¡¨é€™å€‹ç‰©ä»¶ã€ã€‚
//  */

// // [import]ï¼šåŒ¯å…¥æŒ‡ä»¤ã€‚
// // ['package:equatable/equatable.dart']ï¼šå¼•å…¥å¤–éƒ¨å¥—ä»¶ Equatableã€‚
// // ğŸ’¡ æ³¨æ„ï¼šé€™ä¸æ˜¯ Dart å…§å»ºçš„ï¼Œéœ€è¦åœ¨ pubspec.yaml ä¸­æ·»åŠ ä¾è³´æ‰èƒ½ä½¿ç”¨ã€‚
// import 'package:equatable/equatable.dart';

// // [class Point]ï¼šå®šç¾©é¡åˆ¥ Pointã€‚
// // [extends Equatable]ï¼šç¹¼æ‰¿ Equatable é¡åˆ¥ã€‚
// // ğŸ’¡ é—œéµï¼šé€™æ˜¯é­”æ³•ç™¼ç”Ÿçš„åŸå› ã€‚Point ç¾åœ¨ç¹¼æ‰¿äº† Equatable å·²ç¶“å¯«å¥½çš„ == å’Œ hashCode é‚è¼¯ã€‚
// class Point extends Equatable {
  
//   // [const Point]ï¼šå¸¸æ•¸å»ºæ§‹å­ (Constant Constructor)ã€‚
//   // [(this.x, this.y)]ï¼š[this shorthand syntax] (this ç°¡å¯«èªæ³•)ã€‚
//   // è‡ªå‹•å°‡å‚³å…¥çš„ç¬¬ä¸€å€‹å¼•æ•¸è³¦å€¼çµ¦ xï¼Œç¬¬äºŒå€‹çµ¦ yã€‚
//   const Point(this.x, this.y);

//   // [final int x]ï¼šä¸å¯è®Šçš„æˆå“¡è®Šæ•¸ (Immutable Property)ã€‚
//   final int x;
//   // [final int y]ï¼šä¸å¯è®Šçš„æˆå“¡è®Šæ•¸ã€‚
//   final int y;

//   // -------------------------------------------------------
//   // æ ¸å¿ƒè¨­å®šï¼šå®šç¾©æ¯”è¼ƒé‚è¼¯ (The Props Getter)
//   // -------------------------------------------------------
  
//   // [@override]ï¼šè¦†å¯« Equatable å®šç¾©çš„ props å±¬æ€§ã€‚
//   // [List<Object?>]ï¼šå›å‚³å‹åˆ¥ã€‚é€™æ˜¯ä¸€å€‹åŒ…å«æ‰€æœ‰ã€Œåƒèˆ‡æ¯”è¼ƒã€å±¬æ€§çš„æ¸…å–®ã€‚
//   // [get props]ï¼šGetter (è®€å–å™¨)ã€‚
//   // [=> [x, y]]ï¼šç®­é ­èªæ³•ã€‚å›å‚³ä¸€å€‹åŒ…å« x å’Œ y çš„ Listã€‚
//   // ğŸ’¡ é‹ä½œåŸç†ï¼š
//   // ç•¶ä½ åŸ·è¡Œ p1 == p2 æ™‚ï¼ŒEquatable æœƒè‡ªå‹•å»æ¯”è¼ƒé€™å…©å€‹ç‰©ä»¶çš„ props æ¸…å–®ã€‚
//   // å¦‚æœ props è£¡çš„ x å’Œ y éƒ½ä¸€æ¨£ï¼ŒEquatable å°±æœƒåˆ¤å®šé€™å…©å€‹ Point ç›¸ç­‰ã€‚
//   // é€™æ¨£ä½ å°±ä¸ç”¨æ‰‹å¯«ä¸€å † if (other is Point && other.x == x ...) äº†ã€‚
//   @override
//   List<Object?> get props => [x, y];

//   // -------------------------------------------------------
//   // é¸ç”¨è¨­å®šï¼šè‡ªå‹• toString (Stringify)
//   // -------------------------------------------------------

//   // [@override]ï¼šè¦†å¯« stringify å±¬æ€§ã€‚
//   // [bool get stringify]ï¼šGetterï¼Œå›å‚³å¸ƒæ—å€¼ã€‚
//   // [=> true]ï¼šè¨­ç‚º trueï¼Œé–‹å•Ÿ Equatable çš„è‡ªå‹• toString åŠŸèƒ½ã€‚
//   // ğŸ’¡ æ•ˆæœï¼šprint(Point(1, 1)) æœƒè‡ªå‹•å°å‡º "Point(1, 1)"ï¼Œ
//   // ä½ ä¸éœ€è¦è‡ªå·±æ‰‹å¯« toString() æ–¹æ³•äº†ï¼
//   @override
//   bool get stringify => true;

//   // -------------------------------------------------------
//   // é‹ç®—å­é‡è¼‰ (Operator Overloading) - åŠ æ³•èˆ‡ä¹˜æ³•
//   // -------------------------------------------------------
//   // é€™è£¡å±•ç¤ºäº†å³ä½¿ä½¿ç”¨äº† Equatableï¼Œä½ ä¾ç„¶å¯ä»¥å®šç¾©å…¶ä»–çš„é‹ç®—å­è¡Œç‚ºã€‚

//   // [operator +]ï¼šå®šç¾©åŠ æ³•è¡Œç‚ºã€‚
//   Point operator +(Point other) {
//     return Point(x + other.x, y + other.y);
//   }

//   // [operator *]ï¼šå®šç¾©ä¹˜æ³•è¡Œç‚ºã€‚
//   Point operator *(int other) {
//     return Point(x * other, y * other);
//   }
// }

// // [void main()]ï¼šç¨‹å¼é€²å…¥é»ã€‚
// void main() {
//   // -------------------------------------------------------
//   // é©—è­‰ Equatable çš„å¨åŠ›
//   // -------------------------------------------------------

//   // [Point(0, 0) == Point(0, 0)]ï¼šæ¯”è¼ƒå…©å€‹ä¸åŒçš„ç‰©ä»¶å¯¦é«”ã€‚
//   // 1. å› ç‚ºç¹¼æ‰¿äº† Equatableï¼Œå®ƒæœƒå»æª¢æŸ¥ propsã€‚
//   // 2. props æ˜¯ [0, 0] å’Œ [0, 0]ã€‚
//   // 3. å…§å®¹å®Œå…¨ç›¸åŒ -> å›å‚³ trueã€‚
//   // ğŸ’¡ å¦‚æœæ²’æœ‰ Equatableï¼Œé€™è£¡é è¨­æœƒæ˜¯ false (æ¯”è¼ƒè¨˜æ†¶é«”ä½å€)ã€‚
//   print(Point(0, 0) == Point(0, 0)); // è¼¸å‡º: true

//   // [print(...)]ï¼šé©—è­‰ stringify åŠŸèƒ½ã€‚
//   // è¼¸å‡º: Point(x: 1, y: 1) (Equatable é è¨­çš„æ ¼å¼ï¼Œæ¸…æ¥šæ˜“è®€)
//   print(Point(1, 1)); 
// }



// ç‚ºä»€éº¼ä¸€å®šè¦ç”¨ Immutable (ä¸å¯è®Š) é¡åˆ¥ï¼Ÿ

// åœ¨ Equatable æˆ– Flutter é–‹ç™¼ä¸­ï¼Œæˆ‘å€‘å¹¾ä¹ç¸½æ˜¯å®šç¾© final å±¬æ€§ã€‚é€™èƒŒå¾Œæœ‰ä¸‰å¤§ç¡¬æ ¸ç†ç”±ï¼š

// 1. é›œæ¹Šç¢¼çš„ç½é›£ (The HashCode Trap) ğŸ’£

// é€™æ˜¯æœ€æŠ€è¡“æ€§ã€ä¹Ÿæœ€è‡´å‘½çš„åŸå› ã€‚

// åŸç†ï¼šMap å’Œ Set æ˜¯é  hashCode ä¾†æ±ºå®šç‰©ä»¶å­˜æ”¾çš„ä½ç½®ï¼ˆæ¡¶å­ï¼‰ã€‚

// è¦å‰‡ï¼šå¦‚æœå…©å€‹ç‰©ä»¶ç›¸ç­‰ (==)ï¼Œå®ƒå€‘çš„ hashCode å¿…é ˆç›¸åŒã€‚

// ç½é›£å ´æ™¯ï¼š
// å¦‚æœä½ ç”¨ä¸€å€‹ã€Œå¯è®Šç‰©ä»¶ã€ç•¶ä½œ Map çš„ Keyï¼Œç•¶ä½ ä¿®æ”¹äº†ç‰©ä»¶å…§éƒ¨çš„æ•¸å€¼ï¼Œå®ƒçš„ hashCode ä¹Ÿæœƒè·Ÿè‘—è®Šã€‚

// çµæœï¼šä½ è¦ªæ‰‹æŠŠé‘°åŒ™ä¸Ÿé€²å¤§æµ·è£¡ã€‚ä½ æ˜æ˜æ‹¿è‘—åŒä¸€å€‹ç‰©ä»¶ï¼Œå»å†ä¹Ÿæ‰¾ä¸åˆ°å®ƒåœ¨ Map è£¡çš„è³‡æ–™äº†ã€‚